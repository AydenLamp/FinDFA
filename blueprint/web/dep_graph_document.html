

<!DOCTYPE html>
<html>
<head>
  <title>Dependency graph</title>
  <meta name="generator" content="plasTeX" />
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles/theme-white.css" />
  <link rel="stylesheet" href="styles/dep_graph.css" />
  
  <script type="text/x-mathjax-config">
  
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  
  </script>

  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">  </script>


<link rel="stylesheet" href="styles/extra_styles.css" />

</head>

<body>
<header>
  <a class="toc" href="index.html">Home</a>
  <h1 id="doc_title">Dependencies</h1>
</header>
<div class="wrapper">
<div class="content">
  <div id="Legend">
    <span id="legend_title" class="title">Legend
    <div class="btn">
       <div class="bar"></div>
       <div class="bar"></div>
       <div class="bar"></div>
    </div></span> 
    <dl class="legend">
      
      <dt>Boxes</dt><dd>definitions</dd>
      
      <dt>Ellipses</dt><dd>theorems and lemmas</dd>
      
      <dt>Blue border</dt><dd>the <em>statement</em> of this result is ready to be formalized; all prerequisites are done</dd>
      
      <dt>Orange border</dt><dd>the <em>statement</em> of this result is not ready to be formalized; the blueprint needs more work</dd>
      
      <dt>Blue background</dt><dd>the <em>proof</em> of this result is ready to be formalized; all prerequisites are done</dd>
      
      <dt>Green border</dt><dd>the <em>statement</em> of this result is formalized</dd>
      
      <dt>Green background</dt><dd>the <em>proof</em> of this result is formalized</dd>
      
      <dt>Dark green background</dt><dd>the <em>proof</em> of this result and all its ancestors are formalized</dd>
      
      <dt>Dark green border</dt><dd>this is in Mathlib</dd>
      
    </dl>
  </div>
    <div id="graph"></div>
<div id="statements">

    
    <div class="dep-modal-container" id="def:accessible-fin-dfa_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:accessible-fin-dfa" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">3</span><span class="definition_thmtitle">Accessible States and Accessible DFA</span></div>
    <div class="thm_thmcontent"><p>  A state \(s\) in a <span class="ttfamily">FinDFA</span> is called accessible if there exists some word \(w\) that reaches \(s\) from the start state. Formally, <span class="ttfamily">FinDFA.IsAccessibleState M s</span> holds when there exists a word \(w\) such that evaluating \(w\) from the start state of \(M\) results in state \(s\). </p>
<p>An <span class="ttfamily">AccessibleFinDFA</span> is a structure that extends <span class="ttfamily">FinDFA</span> with the additional requirement that every state in the automaton is accessible from the start state. This ensures that the automaton contains no "dead" or unreachable states.   </p>
</div>

    <a class="latex_link" href="sect0001.html#def:accessible-fin-dfa">LaTeX</a>
    
    
  <a class="lean_link lean_decl" href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/AccessibleFinDFA">Lean</a>
    
    
  
    
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:accessible-fin-dfa-le_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:accessible-fin-dfa-le" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">7</span><span class="definition_thmtitle">Partial Order on AccessibleFinDFAs</span></div>
    <div class="thm_thmcontent">
<p>We define a partial order on <span class="ttfamily">AccessibleFinDFA</span>s by the existence of surjective morphisms between their underlying DFAs. </p>
<p>A <em>surjective morphism</em> \(M \twoheadrightarrow N\) between accessible finite DFAs is a morphism on their underlying DFAs that is surjective on states. </p>
<p>We define \(M \leq N\) if and only if there exists a surjective morphism \(N \twoheadrightarrow M\). </p>
<p>This relation satisfies: </p>
<ul class="itemize">
  <li><p><b class="bfseries">Reflexivity</b>: \(M \leq M\) for all \(M\) </p>
</li>
  <li><p><b class="bfseries">Transitivity</b>: If \(M \leq N\) and \(N \leq O\), then \(M \leq O\) </p>
</li>
  <li><p><b class="bfseries">Antisymmetry up to equivalence</b>: If \(M \leq N\) and \(N \leq M\), then \(M.\text{toDFA} \simeq _\ell N.\text{toDFA}\) </p>
</li>
</ul>
<p>An <span class="ttfamily">AccessibleFinDFA</span> \(M\) is <em>minimal</em> if for every \(N\) with \(N \leq M\), we have \(M.\text{toDFA} \simeq _\ell N.\text{toDFA}\). </p>
</div>

    <a class="latex_link" href="sect0002.html#def:accessible-fin-dfa-le">LaTeX</a>
    
    
  <div class="tooltip">
      <span class="lean_link">Lean</span>
      <ul class="tooltip_list">
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/AccessibleFinDFA.HomSurj" class="lean_decl">AccessibleFinDFA.HomSurj</a></li>
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/AccessibleFinDFA.le" class="lean_decl">AccessibleFinDFA.le</a></li>
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/AccessibleFinDFA.le_refl" class="lean_decl">AccessibleFinDFA.le_refl</a></li>
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/AccessibleFinDFA.le_trans" class="lean_decl">AccessibleFinDFA.le_trans</a></li>
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/AccessibleFinDFA.le_antisymm" class="lean_decl">AccessibleFinDFA.le_antisymm</a></li>
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/AccessibleFinDFA.IsMinimal" class="lean_decl">AccessibleFinDFA.IsMinimal</a></li>
        
      </ul>
  </div>
    
    
  
    
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:dfa_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:dfa" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">1</span><span class="definition_thmtitle">Deterministic Finite Automaton (DFA)</span></div>
    <div class="thm_thmcontent"><p>  Mathlib provides a general definition of deterministic finite automata that does not require the state space or alphabet to be finite or have decidable equality. A <span class="ttfamily">DFA</span> \(\alpha \) \(\sigma \) consists of: </p>
<ul class="itemize">
  <li><p><span class="ttfamily">step : \(\sigma \) \(\to \) \(\alpha \) \(\to \) \(\sigma \)</span> - a transition function that maps a state and input symbol to a new state </p>
</li>
  <li><p><span class="ttfamily">start : \(\sigma \)</span> - an initial state </p>
</li>
  <li><p><span class="ttfamily">accept : Set \(\sigma \)</span> - a set of accepting states </p>
</li>
</ul>
<p>The <span class="ttfamily">DFA</span> structure provides methods such as: </p>
<ul class="itemize">
  <li><p><span class="ttfamily">eval : List \(\alpha \) \(\to \) \(\sigma \)</span> - evaluates a word from the start state </p>
</li>
  <li><p><span class="ttfamily">evalFrom : \(\sigma \) \(\to \) List \(\alpha \) \(\to \) \(\sigma \)</span> - evaluates a word from a given state </p>
</li>
  <li><p><span class="ttfamily">accepts : Set (List \(\alpha \))</span> - the language accepted by the automaton </p>
</li>
</ul>
<p>Decidable equality means that for any two elements of a type, we can computationally determine whether they are equal or not. This is essential for implementing algorithms that need to compare states or symbols. </p>
</div>

    <a class="latex_link" href="sect0001.html#def:dfa">LaTeX</a>
    
    
  
    
    
  
    
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:dfa-hom_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:dfa-hom" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">5</span><span class="definition_thmtitle">DFA Morphism</span></div>
    <div class="thm_thmcontent">
<p>A <em>morphism</em> between DFAs \(M : \text{DFA}(\alpha , \sigma _1)\) and \(N : \text{DFA}(\alpha , \sigma _2)\), denoted \(M \to _\ell N\), is a function \(f : \sigma _1 \to \sigma _2\) that preserves: </p>
<ul class="itemize">
  <li><p>The start state: \(f(M.\text{start}) = N.\text{start}\) </p>
</li>
  <li><p>The accepting states: \(q \in M.\text{accept} \iff f(q) \in N.\text{accept}\) </p>
</li>
  <li><p>State transitions: \(f(M.\text{evalFrom}(q, w)) = N.\text{evalFrom}(f(q), w)\) for all states \(q\) and words \(w\) </p>
</li>
</ul>
<p>An <em>equivalence</em> of DFAs, denoted \(M \simeq _\ell N\), is a bijective morphism with an inverse morphism. </p>
</div>

    <a class="latex_link" href="sect0002.html#def:dfa-hom">LaTeX</a>
    
    
  <div class="tooltip">
      <span class="lean_link">Lean</span>
      <ul class="tooltip_list">
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/DFA.Hom" class="lean_decl">DFA.Hom</a></li>
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/DFA.Equiv" class="lean_decl">DFA.Equiv</a></li>
        
      </ul>
  </div>
    
    
  
    
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:fin-dfa_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:fin-dfa" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">2</span><span class="definition_thmtitle">Computable Finite DFA</span></div>
    <div class="thm_thmcontent">
<ul class="itemize">
  <li><p>It requires <span class="ttfamily">Fintype</span> instances on both the alphabet \(\alpha \) and state space \(\sigma \). A <span class="ttfamily">Fintype</span> is a type that has finitely many elements and provides a way to enumerate all of them. </p>
</li>
  <li><p>It requires <span class="ttfamily">DecidableEq</span> instances on both types, enabling computational equality testing. </p>
</li>
  <li><p>The accepting states are represented as a <span class="ttfamily">Finset</span> \(\sigma \) rather than a <span class="ttfamily">Set</span> \(\sigma \). A <span class="ttfamily">Finset</span> is a finite set that can be computationally manipulated, unlike the more general <span class="ttfamily">Set</span> which may be infinite or non-computable. </p>
</li>
</ul>
<p>This structure allows for a decidable procedure to determine if a state is accepting - we can simply check membership in the finite set of accepting states. We provide a coercion from <span class="ttfamily">FinDFA</span> to <span class="ttfamily">DFA</span>, allowing us to use all the existing <span class="ttfamily">DFA</span> definitions for evaluation and language acceptance.  </p>
</div>

    <a class="latex_link" href="sect0001.html#def:fin-dfa">LaTeX</a>
    
    
  <a class="lean_link lean_decl" href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/FinDFA">Lean</a>
    
    
  
    
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="def:nerode-equiv_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="def:nerode-equiv" style="display: none">
    <div class="thm_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">8</span><span class="definition_thmtitle">Nerode Equivalence</span></div>
    <div class="thm_thmcontent">
<p>Let \(M\) be an <span class="ttfamily">AccessibleFinDFA</span> with alphabet \(\alpha \) and state space \(\sigma \). </p>
<p>A word \(w\) <em>indistinguishes</em> two states \(s_1, s_2 \in \sigma \), denoted \(\text{Indist}_M(w, s_1, s_2)\), if evaluating from both states with input \(w\) leads to the same acceptance outcome: </p>
<div class="displaymath" id="a0000000007">
  \[ M.\text{evalFrom}(s_1, w) \in M.\text{accept} \iff M.\text{evalFrom}(s_2, w) \in M.\text{accept} \]
</div>
<p>The <em>Nerode equivalence relation</em> \(\sim _{\text{Nerode}}\) on states is defined by: </p>
<div class="displaymath" id="a0000000008">
  \[ s_1 \sim _{\text{Nerode}} s_2 \iff \forall w : \text{List}(\alpha ), \text{Indist}_M(w, s_1, s_2) \]
</div>
<p>Two states are Nerode equivalent if and only if all words indistinguish them. </p>
<p>The <em>bounded Nerode equivalence relation</em> \(\sim _{\text{Nerode}}^{(n)}\) at level \(n\) is defined by: </p>
<div class="displaymath" id="a0000000009">
  \[ s_1 \sim _{\text{Nerode}}^{(n)} s_2 \iff \forall w : \text{List}(\alpha ), |w| \leq n \implies \text{Indist}_M(w, s_1, s_2) \]
</div>
<p>Both relations are equivalence relations (reflexive, symmetric, and transitive). </p>
<p>Since the alphabet \(\alpha \) is finite, there are only finitely many words of length \(\leq n\), making \(\sim _{\text{Nerode}}^{(n)}\) decidable. </p>
</div>

    <a class="latex_link" href="sect0003.html#def:nerode-equiv">LaTeX</a>
    
    
  <div class="tooltip">
      <span class="lean_link">Lean</span>
      <ul class="tooltip_list">
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/AccessibleFinDFA.Indist" class="lean_decl">AccessibleFinDFA.Indist</a></li>
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/AccessibleFinDFA.nerode" class="lean_decl">AccessibleFinDFA.nerode</a></li>
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/AccessibleFinDFA.boundedNerode" class="lean_decl">AccessibleFinDFA.boundedNerode</a></li>
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/AccessibleFinDFA.boundedNerodeComputable" class="lean_decl">AccessibleFinDFA.boundedNerodeComputable</a></li>
        
      </ul>
  </div>
    
    
  
    
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:bounded-nerode-stabilizes_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:bounded-nerode-stabilizes" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">9</span><span class="lemma_thmtitle">Bounded Nerode Stabilization</span></div>
    <div class="thm_thmcontent">
<p>The bounded Nerode relation satisfies the following properties: </p>
<ol class="enumerate">
  <li><p><b class="bfseries">Monotonicity</b>: For \(n \leq m\), we have \(\sim _{\text{Nerode}}^{(m)} \subseteq \sim _{\text{Nerode}}^{(n)}\) (the relation becomes finer as the bound increases). </p>
</li>
  <li><p><b class="bfseries">Stabilization</b>: If \(\sim _{\text{Nerode}}^{(n)} = \sim _{\text{Nerode}}^{(n+1)}\), then \(\sim _{\text{Nerode}}^{(n)} = \sim _{\text{Nerode}}^{(m)}\) for all \(m \geq n\). </p>
</li>
  <li><p><b class="bfseries">Finite stabilization</b>: The relation stabilizes at or before level \(|\sigma |\), i.e., \(\sim _{\text{Nerode}}^{(|\sigma |)} = \sim _{\text{Nerode}}^{(|\sigma |+1)}\). </p>
</li>
  <li><p><b class="bfseries">Equivalence with unbounded relation</b>: \(\sim _{\text{Nerode}}^{(|\sigma |)} = \sim _{\text{Nerode}}\). </p>
</li>
</ol>
</div>

    <a class="latex_link" href="sect0003.html#lem:bounded-nerode-stabilizes">LaTeX</a>
    
    
  <div class="tooltip">
      <span class="lean_link">Lean</span>
      <ul class="tooltip_list">
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/AccessibleFinDFA.boundedNerode_mono" class="lean_decl">AccessibleFinDFA.boundedNerode_mono</a></li>
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/AccessibleFinDFA.boundedNerode_stable" class="lean_decl">AccessibleFinDFA.boundedNerode_stable</a></li>
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/AccessibleFinDFA.boundedNerode_stable_eq_nerode" class="lean_decl">AccessibleFinDFA.boundedNerode_stable_eq_nerode</a></li>
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/AccessibleFinDFA.boundedNerodeFinpartition_parts_eq_of_card_eq" class="lean_decl">AccessibleFinDFA.boundedNerodeFinpartition_parts_eq_of_card_eq</a></li>
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/AccessibleFinDFA.boundedNerodeFinpartition_stabilized" class="lean_decl">AccessibleFinDFA.boundedNerodeFinpartition_stabilized</a></li>
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/AccessibleFinDFA.boundedNerode_eq_nerode" class="lean_decl">AccessibleFinDFA.boundedNerode_eq_nerode</a></li>
        
      </ul>
  </div>
    
    
  
    
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:exists-short-access-word_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:exists-short-access-word" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">4</span><span class="lemma_thmtitle">Short Access Words and Decidable Accessibility</span></div>
    <div class="thm_thmcontent"><p>  A fundamental result for implementing accessibility checking is that if a state is accessible by any word, then it is accessible by some word of length at most the number of states in the automaton. This bound follows from the pigeonhole principle: if a longer word exists, it must revisit some state, creating a loop that can be removed. </p>
<p>This theorem enables us to create a decidable procedure for determining state accessibility. Instead of searching the infinite space of all possible words, we only need to check words up to a finite length bound. Using the <span class="ttfamily">getWordsLeqLength</span> function, we can enumerate all words of bounded length and test each one. </p>
<p>Furthermore, this allows us to implement a language-preserving conversion from any <span class="ttfamily">FinDFA</span> to an <span class="ttfamily">AccessibleFinDFA</span> by restricting the state space to only the accessible states. The resulting automaton accepts exactly the same language as the original.   </p>
</div>

    <a class="latex_link" href="sect0001.html#lem:exists-short-access-word">LaTeX</a>
    
    
  <div class="tooltip">
      <span class="lean_link">Lean</span>
      <ul class="tooltip_list">
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/FinDFA.exists_short_access_word" class="lean_decl">FinDFA.exists_short_access_word</a></li>
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/FinDFA.toAccessible" class="lean_decl">FinDFA.toAccessible</a></li>
        
           <li><a href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/FinDFA.toAccessible_pres_lang" class="lean_decl">FinDFA.toAccessible_pres_lang</a></li>
        
      </ul>
  </div>
    
    
  
    
  </div>
    
      </div>
    </div>


    
    <div class="dep-modal-container" id="lem:hom-pres-lang_modal">
      <div class="dep-modal-content">
          <button class="dep-closebtn">
<svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        
  <div class="thm" id="lem:hom-pres-lang" style="display: none">
    <div class="thm_thmheading">
      <span class="lemma_thmcaption">
      Lemma
      </span>
      <span class="lemma_thmlabel">6</span><span class="lemma_thmtitle">Morphism Preserves Language</span></div>
    <div class="thm_thmcontent">
<p>If there exists a morphism \(f : M \to _\ell N\), then \(M.\text{accepts} = N.\text{accepts}\). </p>
</div>

    <a class="latex_link" href="sect0002.html#lem:hom-pres-lang">LaTeX</a>
    
    
  <a class="lean_link lean_decl" href="https://AydenLamp.github.io/FinDFA/docs/find/#doc/DFA.Hom.pres_lang">Lean</a>
    
    
  
    
  </div>
    
      </div>
    </div>
</div>
</div> <!-- content -->
</div> <!-- wrapper -->
<script src="js/jquery.min.js" type="text/javascript"></script>

<script src="js/d3.min.js"></script>
<script src="js/hpcc.min.js"></script>
<script src="js/d3-graphviz.js"></script>

<script type="text/javascript">
const graphContainer = d3.select("#graph");
const width = graphContainer.node().clientWidth;
const height = graphContainer.node().clientHeight;


graphContainer.graphviz({useWorker: true})
    .width(width)
    .height(height)
    .fit(true)
    .renderDot(`strict digraph "" {	graph [bgcolor=transparent];	node [label="\N",		penwidth=1.8	];	edge [arrowhead=vee];	"def:accessible-fin-dfa"	[color=green,		fillcolor="#B0ECA3",		label="accessible-fin-dfa",		shape=box,		style=filled];	"def:nerode-equiv"	[color=blue,		fillcolor="#A3D6FF",		label="nerode-equiv",		shape=box,		style=filled];	"def:accessible-fin-dfa" -> "def:nerode-equiv"	[style=dashed];	"lem:exists-short-access-word"	[color=green,		fillcolor="#1CAC78",		label="exists-short-access-word",		shape=ellipse,		style=filled];	"def:accessible-fin-dfa" -> "lem:exists-short-access-word"	[style=dashed];	"def:accessible-fin-dfa-le"	[label="accessible-fin-dfa-le",		shape=box];	"def:accessible-fin-dfa" -> "def:accessible-fin-dfa-le"	[style=dashed];	"lem:bounded-nerode-stabilizes"	[label="bounded-nerode-stabilizes",		shape=ellipse];	"def:nerode-equiv" -> "lem:bounded-nerode-stabilizes"	[style=dashed];	"def:dfa-hom"	[color=blue,		fillcolor="#A3D6FF",		label="dfa-hom",		shape=box,		style=filled];	"def:dfa-hom" -> "def:accessible-fin-dfa-le"	[style=dashed];	"lem:hom-pres-lang"	[label="hom-pres-lang",		shape=ellipse];	"def:dfa-hom" -> "lem:hom-pres-lang"	[style=dashed];	"def:dfa"	[color=green,		fillcolor="#B0ECA3",		label=dfa,		shape=box,		style=filled];	"def:dfa" -> "def:dfa-hom"	[style=dashed];	"def:fin-dfa"	[color=green,		fillcolor="#B0ECA3",		label="fin-dfa",		shape=box,		style=filled];	"def:fin-dfa" -> "def:accessible-fin-dfa"	[style=dashed];}`)
    .on("end", interactive);

latexLabelEscaper = function(label) {
  return label.replace(/\./g, '\\.').replace(/:/g, '\\:')
}

clickNode = function() {
  $("#statements div").hide()
  var node_id = $('text', this).text();
  $('.thm').hide();
  $('#'+latexLabelEscaper(node_id)).show().children().show();
}
function interactive() {
    $("span#legend_title").on("click", function () {
           $(this).siblings('dl').toggle();
        })

    d3.selectAll('.node')
        .attr('pointer-events', 'fill')
        .on('click', function () {
           var title = d3.select(this).selectAll('title').text().trim();
           $('#statements > div').hide()
           $('.thm').hide();
           $('#'+latexLabelEscaper(title)+'_modal').show().children().show().children().show();
           $('#statements').show()
        });

    d3.selectAll('.dep-closebtn').on('click', function() {
        var modal =
            d3.select(this).node().parentNode.parentNode.parentNode ;
        d3.select(modal).style('display', 'none');
    });
}

</script>

</body>
</html>
